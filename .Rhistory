require(psych)
require(corrplot)
require(caret)
require(tidyverse)
require(pls)
require(glmnet)
require(gdata)
require(Matrix)
require(graphics)
require(rpart)
require(randomForest)
require(gbm)
require(earth)
require(caretEnsemble)
train_data <- read.csv("../Data/train.csv")
test_data <- read.csv("../Data/test.csv")
train_data <- read.csv("/Data/train.csv")
train_data <- read.csv("./Data/train.csv")
test_data <- read.csv("./Data/test.csv")
##### Changing training dataset
house_train <- train_data[,c(-1,-2,-18,-19)]
house_train$zipcode <- as.factor(house_train$zipcode)
house_train$waterfront <- as.factor(house_train$waterfront)
house_train$condition <- as.factor(house_train$condition)
findLinearCombos(house_train)
?findLinearCombos
##### The following determines if the design matrix is full rank and then identifies the column/set of columns that
#### are involved in dependencies.
findLinearCombos(house_train)
house_train <- house_train[,-12]
train_data <- read.csv("./Data/train.csv")
test_data <- read.csv("./Data/test.csv")
##### Changing training dataset
house_train <- train_data[,c(-1,-2,-18,-19)]
house_train$zipcode <- as.factor(house_train$zipcode)
house_train$waterfront <- as.factor(house_train$waterfront)
house_train$condition <- as.factor(house_train$condition)
house_train
##### Replicating  the same changes in the test data set
house_test <- test_data[,c(-1,-2,-3,-18,-19)]
house_test$zipcode <- as.factor(house_test$zipcode)
house_test$waterfront <- as.factor(house_test$waterfront)
house_test$condition <- as.factor(house_test$condition)
findLinearCombos(house_test)
house_test <- house_test[,-11]
method<- c("knn","rpart","rf")
parameter <- list(data.frame(k=4),
data.frame(cp=0.0001),
data.frame(mtry=47))
pred1<- list()
pred2<- list()
pred11<- list()
pred21<- list()
train<- house_train
test<- house_test
pred1<- matrix(NA,nrow=dim(test)[1],ncol=5)
pred2<- matrix(NA,nrow=dim(train)[1],ncol=3)
pred11<- matrix(NA,nrow=dim(train)[1],ncol=5)
pred21<- matrix(NA,nrow=dim(train)[1],ncol=3)
for (j in 1:3){
modelfit<- train(price~.,
data=train,
method=method[j],
preProc=c("center","scale"),
trControl=trainControl(method="none"),
tuneGrid=parameter[[j]])
pred1[,j]<- predict(modelfit,newdata=test)
pred2[,j]<- predict(modelfit,newdata=train[,-1])
pred11[,j]<- predict(modelfit,newdata=train[,-1])
pred21[,j]<- predict(modelfit,newdata=train[,-1])
}
test
pred1
emfitLM<- lm(log(train$price)~as.matrix(log(pred2)))
pred1<- list()
pred2<- list()
pred11<- list()
pred21<- list()
train<- house_train
test<- house_test
pred1<- matrix(NA,nrow=dim(test)[1],ncol=5)
pred2<- matrix(NA,nrow=dim(train)[1],ncol=3)
pred11<- matrix(NA,nrow=dim(train)[1],ncol=5)
pred21<- matrix(NA,nrow=dim(train)[1],ncol=3)
train
Stacking_Prediction_housePrice_RF <- predictionsTest$enFOR %>%as.data.frame()
house_test
train_data <- read.csv("./Data/train.csv")
test_data <- read.csv("./Data/test.csv")
##### Changing training dataset
house_train <- train_data[,c(-1,-2,-18,-19)]
house_train$zipcode <- as.factor(house_train$zipcode)
house_train$waterfront <- as.factor(house_train$waterfront)
house_train$condition <- as.factor(house_train$condition)
##### The following determines if the design matrix is full rank and then identifies the column/set of columns that
#### are involved in dependencies.
findLinearCombos(house_train)
house_train
colnames(house_train)
house_train <- house_train[,-12]
colnames(house_train)
test_data
names(house_test)
names(test_data)
train_data <- read.csv("./Data/train.csv")
test_data <- read.csv("./Data/test.csv")
names(test_data)
names(train_data)
names(test_data)
##### Changing training dataset
house_train <- train_data[,c(-1,-2,-18,-19)]
house_train$zipcode <- as.factor(house_train$zipcode)
house_train$waterfront <- as.factor(house_train$waterfront)
house_train$condition <- as.factor(house_train$condition)
##### The following determines if the design matrix is full rank and then identifies the column/set of columns that
#### are involved in dependencies.
findLinearCombos(house_train)
house_train <- house_train[,-12]
colnames(house_train)
##### Replicating  the same changes in the test data set
house_test <- test_data[,c(-1,-2,-3,-18,-19)]
house_test$zipcode <- as.factor(house_test$zipcode)
house_test$waterfront <- as.factor(house_test$waterfront)
house_test$condition <- as.factor(house_test$condition)
findLinearCombos(house_test)
colnames(house_test)
findLinearCombos(house_test)
house_test <- house_test[,-11]
colnames(house_test)
colnames(house_train)
method<- c("knn","rpart","rf")
parameter <- list(data.frame(k=4),
data.frame(cp=0.0001),
data.frame(mtry=47))
pred1<- list()
pred2<- list()
pred11<- list()
pred21<- list()
train<- house_train
test<- house_test
pred1<- matrix(NA,nrow=dim(test)[1],ncol=5)
pred2<- matrix(NA,nrow=dim(train)[1],ncol=3)
pred11<- matrix(NA,nrow=dim(train)[1],ncol=5)
pred21<- matrix(NA,nrow=dim(train)[1],ncol=3)
for (j in 1:3){
modelfit<- train(price~.,
data=train,
method=method[j],
preProc=c("center","scale"),
trControl=trainControl(method="none"),
tuneGrid=parameter[[j]])
pred1[,j]<- predict(modelfit,newdata=test)
pred2[,j]<- predict(modelfit,newdata=train[,-1])
pred11[,j]<- predict(modelfit,newdata=train[,-1])
pred21[,j]<- predict(modelfit,newdata=train[,-1])
}
parameter <- list(data.frame(k=4),
data.frame(cp=0.0001),
data.frame(mtry=47))
parameter
parameter <- list(data.frame(k=4),
data.frame(cp=0.01),
data.frame(mtry=47))
pred1<- list()
pred2<- list()
pred11<- list()
pred21<- list()
train<- house_train
test<- house_test
pred1<- matrix(NA,nrow=dim(test)[1],ncol=5)
pred2<- matrix(NA,nrow=dim(train)[1],ncol=3)
pred11<- matrix(NA,nrow=dim(train)[1],ncol=5)
pred21<- matrix(NA,nrow=dim(train)[1],ncol=3)
for (j in 1:3){
modelfit<- train(price~.,
data=train,
method=method[j],
preProc=c("center","scale"),
trControl=trainControl(method="none"),
tuneGrid=parameter[[j]])
pred1[,j]<- predict(modelfit,newdata=test)
pred2[,j]<- predict(modelfit,newdata=train[,-1])
pred11[,j]<- predict(modelfit,newdata=train[,-1])
pred21[,j]<- predict(modelfit,newdata=train[,-1])
}
